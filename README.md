# TangoCode Java Android Style Guide

## Introduction

This document serves as the **complete** definition of TangoCodes's coding standards for source code in the Java Android™ Programming Language.

**Note:** Suggestions for improvements are highly encouraged.

###Version Control

For any reason the IDE configuration files should be committed to the version control. For instance, for our Android projects we are using Android Studio and for our general version control system we use Git. Any time we open Android Studio, it creates a lot of configuration files like *.iml files that should never be committed. So, anytime we crate a new project in Android Studio, before doing the initial commit we have to make sure that the .gitignore file looks like this.
```
DS_Store
/captures

### Android ###
# Built application files
*.apk
*.ap_

# Files for the Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

### Android Patch ###
gen-external-apklibs

*.iml
*.iws
*.ipr
.idea/
local.properties
*~
*.swp
.idea/runConfigurations.xml
```

###Comments and Java doc

The Java doc tool generates an HTML document that contains the documentation of our source code. In order to generate useful documentation using this tool, Java doc provides a set of guidelines and tags that we should include in our code.

Generally a doc comment precedes classes, interfaces, fields, and methods. These doc comments are made up of two parts; A description and a set of tags such as: @author @version @param @return @deprecated @since @throws @exception @see @serial @serialField @serialData (According to the Java doc standards, these tags should be written in the same order). 

Doc comments should start with /** and end up with */ and the description should be separated from the tags by a break line.

Next you will se a set of examples the we use at TangoCode to make Classes, Interfaces, Methods, and Inline comments.

####Header Comments
**@author:** Name of the person who created it.

**@created:** Date when the object was created, date should be in this format YYYY-MM-DD.

**@changes:** Describe the change done. Leave empty if no modification has been made. If changes, include the Date (YYYY-MM-DD), Name of who made the change.


```
/**
 * Graphics is the abstract base class for all graphics contexts
 * which allow an application to draw onto components realized on
 * various devices or onto off-screen images.
 * <p>
 * Some important points to consider are that drawing a figure that
 * covers a given rectangle will occupy one extra row of pixels on
 * the right and bottom edges compared to filling a figure that is
 * bounded by that same rectangle.
 * 
 * @author      Sami Shaio
 * @author      Arthur van Hoff
 * @created     2015-08-04
 */
public abstract class Graphics {

}
```

###Method Comments

Use this to comment structure for methods that provide important functionality in your code. Getters or Setters do not need to be commented because they are self explanatory. Comments should be in english ONLY.

**@author:** Name of the person who created it 

**@created:** Date when the object was created, date should be in this format YYYY-MM-DD 

**@param:** Parameters that the method receives, create as many parameters as your method receives. Leave empty if the method does not receive parameters

**@return:**.What the method returns

**@throws: **This tag should be included for any checked exceptions (declared in the throws clause) and also for any unchecked exceptions that the caller might reasonably want to catch.
```
/**
 * Returns an Image object that can then be painted on the screen. 
 * The url argument must specify an absolute {@link URL}. The name
 * argument is a specifier that is relative to the url argument. 
 *
 * @author Author's Name
 * @param  url  an absolute URL giving the base location of the image
 * @param  name the location of the image, relative to the url argument
 * @return      the image at the specified URL
 */
 public Image getImage(URL url, String name) {
        try {
            return getImage(new URL(url, name));
        } catch (MalformedURLException e) {
            return null;
        }
 }
```
###Inline Comments

Use this to comment structure for methods that provide important functionality in your code. Getters or Setters do not need to be commented because they are self explanatory. Comments should be in english ONLY

####Good Example
```
// display state selection for US users
var countryCode = getCountry()
if (countryCode == 'US') {
    println()
}

Bad Example
// get the country code
countryCode = getCountry()
// if country code is US
if (countryCode == 'US') {
    // display the form input for state
    println()
}
```
###Naming Standards

####Object Naming

This applies to Classes, Interfaces, Enums. Objects names are written in UpperCamelCase. For classes that extend an Android component, the name of the class should end with the name of the component; for example: SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog.

```
public class GameResultListActivity extends ActionBarActivity{
}
```

####Method Naming

Method names are written in lowerCamelCase
```
public getStartIntent(Contex context, User user) {
    Intent intent = new Intent (context, ThisActivity.class);
    intent.putParcelableExtra(EXTRA_USER, user);
    return intent;
}
```

####Variables Naming

Member variables, local variables and Non-constant field names are written in lowerCamelCase. Fields should be defined at the **top of the file** and they should follow the naming rules listed below.

*   Private, non-static field names start with **m**.
*   Private, static field names start with **s**.
*   Other fields start with a lower case letter.
*   Static final fields (constants) are ALL_CAPS_WITH_UNDERSCORES.

*Example:*

```
public class MyClass {
    public static final int SOME_CONSTANT = 42;
    public int publicField;
    private static MyClass sSingleton;
    int mPackagePrivate;
    private int mPrivate;
    protected int mProtected;
}
```


**Constants Naming**

Constant names use CONSTANT_CASE

```
public class MyClass {
    public static final int SOME_CONSTANT = 42;
}
```

### Parameter ordering in methods

When programming for Android, it is quite common to define methods that take a `Context`. If you are writing a method like this, then the **Context** must be the **first** parameter.

The opposite case are **callback** interfaces that should always be the **last** parameter.

Examples:


// Context always go first
public User loadUser(Context context, int userId);

// Callbacks always go last
public void loadUserAsync(Context context, int userId, UserCallback callback);

**Control flow statements (Conditions / Loops / etc.)**

Brackets go on the same line as the conditions, e.g.

```
if (foobar) {
    ...
} else {
    ...
}
for (foo; foo; foo) {
    ...
}

```
**Single line control flow statements**

Should still have braces. e.g.

```
if (foobar) {
    ...
} else {
    ...
}
```

**TODOs / FIXMEs / DRAGONs**

Use comment lines right inside the code with standard formats that indicated the severity of the technical debt, the rough estimate of its effort, and the name of the individual that discovered it or made the decision to implement it. Comments should be in english ONLY

**Severity types:**

TODO: Something that would not affect the end user of the product but would be a nice thing to address for maintainability or performance.

FIXME Was something that had a chance of affecting the end user or at least compromise the running system in some way.

DRAGON. A disaster waiting to happen and needs to be fixed asap

**Estimate:**

SMALL: Being a day or less

MEDIUM: Being on the order of days to a week

LARGE: Being more than a week


//DRAGON MEDIUM (jvalencia): Added this for some reason

int adjustErrorWidth = 320;

**One statement per line**

Each statement is followed by a line-break.

**Column limit**

Each sentence should not have more than 100 characters

**Line-wrapping strategies**



There isn't an exact formula that explains how to line-wrap and quite often different solutions are valid. However there are a few rules that can be applied to common cases.

**Method chain case**

When multiple methods are chained in the same line - for example when using Builders - every call to a method should go in its own line, breaking the line before the `.`


**Extra lines**

Commented Code should be removed unless there is a specific reason where the Team and PO agreed to keep it

Logs that are not useful should be deleted


**Whitespaces**

Space only. 4-space indents.

### Resources

**Layouts**

**Naming.**Follow the convention of prefixing the type, as in `type_foo_bar.xml`. Examples:`fragment_contact_details.xml`, `view_primary_button.xml`, `activity_main.xml`.

**Organizing layout XMLs.** If you're unsure how to format a layout XML, the following convention may help.

*   One attribute per line, indented by 4 spaces
*   `android:id`as the first attribute always
*   `android:layout_****`attributes at the top
*   `style`attribute at the bottom
*   Tag closer `/>` on its own line, to facilitate ordering and adding attributes.
*   Rather than hard coding `android:text`, consider using [Designtime attributes](http://tools.android.com/tips/layout-designtime-attributes) available for Android Studio.

```
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    >

    <TextView
        android:id="@+id/name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:text="@string/name"
        style="@style/FancyText"
        />

    <include layout="@layout/reusable_part" />

</LinearLayout>

``` 

**strings.xml**

Name your strings with keys that resemble namespaces, and don't be afraid of repeating a value for two or more keys. Languages are complex, so namespaces are necessary to bring context and break ambiguity.

**Bad**

```
<string name="network_error">Network error</string>
<string name="call_failed">Call failed</string>
<string name="map_failed">Map loading failed</string>
```

**Good**

```
<string name="error.message.network">Network error</string>
<string name="error.message.call">Call failed</string>
<string name="error.message.map">Map loading failed</string>
```

Don't write string values in all uppercase. Stick to normal text conventions (e.g., capitalize first character). If you need to display the string in all caps, then do that using for instance the attribute[`textAllCaps`](http://developer.android.com/reference/android/widget/TextView.html#attr_android:textAllCaps) on a TextView.

**Bad**
```
<string name="error.message.call">CALL FAILED</string>
```
**Good**
```
<string name="error.message.call">Call failed</string>
```

**Use styles**

Almost every project needs to properly use styles, because it is very common to have a repeated appearance for a view. At least you should have a common style for most text content in the application, for example:

```
<style name="ContentText">
    <item name="android:textSize">@dimen/font_normal</item>
    <item name="android:textColor">@color/basic_black</item>
</style>
```

Applied to TextViews:

```
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/price"
    style="@style/ContentText"
    />
```

You probably will need to do the same for buttons, but don't stop there yet. Go beyond and move a group of related and repeated `android:****` attributes to a common style.

**Split a large style file into other files.** You don't need to have a single `styles.xml` file. Android SDK supports other files out of the box, there is nothing magical about the name `styles`, what matters are the XML tags `<style>` inside the file. Hence you can have files `styles.xml`, `styles_home.xml`, `styles_item_details.xml`, `styles_forms.xml`. Unlike resource directory names which carry some meaning for the build system, filenames in `res/values` can be arbitrary.


**colors.xml**

colors.xml

colors.xml is a color palette. There should be nothing else in your colors.xml than just a mapping from a color name to an RGBA value. Do not use it to define RGBA values for different types of buttons.

Don't do this:
```
<resources>
    <color name="button_foreground">#FFFFFF</color>
    <color name="button_background">#2A91BD</color>
    <color name="comment_background_inactive">#5F5F5F</color>
    <color name="comment_background_active">#939393</color>
    <color name="comment_foreground">#FFFFFF</color>
    <color name="comment_foreground_important">#FF9D2F</color>
    ...
    <color name="comment_shadow">#323232</color>
```
You can easily start repeating RGBA values in this format, and that makes it complicated to change a basic color if needed. Also, those definitions are related to some context, like "button" or "comment", and should live in a button style, not incolors.xml.

Instead, do this:
```
<resources>

    <!-- grayscale -->
    <color name="white"     >#FFFFFF</color>
    <color name="gray_light">#DBDBDB</color>
    <color name="gray"      >#939393</color>
    <color name="gray_dark" >#5F5F5F</color>
    <color name="black"     >#323232</color>

    <!-- basic colors -->
    <color name="green">#27D34D</color>
    <color name="blue">#2A91BD</color>
    <color name="orange">#FF9D2F</color>
    <color name="red">#FF432F</color>

</resources>

```
Ask for this palette from the designer of the application. The names do not need to be color names as "green", "blue", etc. Names such as "brand_primary", "brand_secondary", "brand_negative" are totally acceptable as well. Formatting colors as such will make it easy to change or refactor colors, and also will make it explicit how many different colors are being used. Normally for a aesthetic UI, it is important to reduce the variety of colors being used.

**dimens.xml**

Treat dimens.xml like colors.xml. You should also define a "palette" of typical spacing and font sizes, for basically the same purposes as for colors. A good example of a dimens file:
```
<resources>

    <!-- font sizes -->
    <dimen name="font_larger">22sp</dimen>
    <dimen name="font_large">18sp</dimen>
    <dimen name="font_normal">15sp</dimen>
    <dimen name="font_small">12sp</dimen>

    <!-- typical spacing between two views -->
    <dimen name="spacing_huge">40dp</dimen>
    <dimen name="spacing_large">24dp</dimen>
    <dimen name="spacing_normal">14dp</dimen>
    <dimen name="spacing_small">10dp</dimen>
    <dimen name="spacing_tiny">4dp</dimen>

    <!-- typical sizes of views -->
    <dimen name="button_height_tall">60dp</dimen>
    <dimen name="button_height_normal">40dp</dimen>
    <dimen name="button_height_short">32dp</dimen>

</resources>
```
You should use the spacing_**** dimensions for layouting, in margins and paddings, instead of hard-coded values, much like strings are normally treated. This will give a consistent look-and-feel, while making it easier to organize and change styles and layouts.

### Package Structure

#### App

    com.futurice.project
    ├─ network
    ├─ models
    ├─ managers
    ├─ utils
    ├─ fragments
    └─ views
       ├─ adapters
       ├─ actionbar
       ├─ widgets
       └─ notifications


### Class member ordering

There is no single correct solution for this but using a **logical** and **consistent** order will improve code learnability and readability. It is recommendable to use the following order:

1.  Constants
2.  Fields
3.  Constructors
4.  Override methods and callbacks (public or private)
5.  Public methods
6.  Private methods
7.  Inner classes or interfaces

Example:
```
public class MainActivity extends Activity {

    private String mTitle;
    private TextView mTextViewTitle;

    public void setTitle(String title) {
        mTitle = title;
    }

    @Override 
    public void onCreate() {
        ...
    }

    private void setUpView() {
        ...
    }

    static class AnInnerClass {

    }

} 
```

If your class is extending and Android component such as an Activity or a Fragment, it is a good practice to order the override methods so that they match the component's lifecycle. For example, if you have an Activity that implementsonCreate(), onDestroy(), onPause() and onResume(), then the correct order is:

```
public class MainActivity extends Activity {

    //Order matches Activity lifecycle  
    @Override 
    public void onCreate() {} 

    @Override 
    public void onResume() {}

    @Override 
    public void onPause() {}

    @Override 
    public void onDestory() {}

}
```


###Exception Handling

You must never do the following:

```
void setServerPort(String value) {
    try {
        serverPort = Integer.parseInt(value);
    } catch (NumberFormatException e) { }
}
```

You must never do this. While you may think that your code will never encounter this error condition or that it is not important to handle it, ignoring exceptions like above creates mines in your code for someone else to trip over some day. You must handle every Exception in your code in some principled way. The specific handling varies depending on the case.

####Don't catch generic exception

You should not do this:

```
try {
    someComplicatedIOFunction();        // may throw IOException 
    someComplicatedParsingFunction();   // may throw ParsingException 
    someComplicatedSecurityFunction();  // may throw SecurityException 
    // phew, made it all the way 
} catch (Exception e) {                 // I'll just catch all exceptions 
    handleError();                      // with one generic handler!
}

```

####Don't ignore exceptions

Pros: can be handy for doing cleanup, particularly of external resources.

Cons: there are no guarantees as to when a finalizer will be called, or even that it will be called at all.

Decision: we don't use finalizers. In most cases, you can do what you need from a finalizer with good exception handling. If you absolutely need it, define a close() method (or the like) and document exactly when that method needs to be called. See InputStream for an example. In this case it is appropriate but not required to print a short log message from the finalizer, as long as it is not expected to flood the logs.


### Fully qualify imports



This is bad: `import foo.*;`

This is good: `import foo.Bar;`

### Logging guidelines


Use the logging methods provided by the `Log` class to print out error messages or other information that may be useful for developers to identifiy issues:

*   `Log.v(String tag, String msg)` (verbose)
*   `Log.d(String tag, String msg)` (debug)
*   `Log.i(String tag, String msg)` (information)
*   `Log.w(String tag, String msg)` (warning)
*   `Log.e(String tag, String msg)` (error)

As a general rule, we use the class name as tag and we define it as a `static final` field at the top of the file. For example:

```
public class MyClass {
    private static final String TAG = "MyClass";

    public myMethod() {
        Log.e(TAG, "My error message");
    }
}
```

VERBOSE and DEBUG logs **must** be disable on relase builds. It is also recommendable to disable INFORMATION, WARNING and ERROR logs but you may want to keep them enable if you think they may be useful to identify issues on release builds. If you decide to leave them enable, you have to make sure that they are not leaking private information such as email addresses, user ids, etc.

To only show logs on debug builds:

```if (BuildConfig.DEBUG) Log.d(TAG, "The value of x is " + x);```
